#pragma config(Sensor, in1,    armAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in2,    hugAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in3,    ratchetAngleSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  FLEncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  BLEncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  FREncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  BREncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, auto3,          sensorDigitalIn)
#pragma config(Sensor, dgtl11, auto1,          sensorDigitalIn)
#pragma config(Sensor, dgtl12, auto2,          sensorDigitalIn)
#pragma config(Motor,  port1,           LHug,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           L1Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           FLDrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BLDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           L2Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           R1Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R2Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           FRDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           BRDrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          armLock,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "./joysticks.h"
#include "./xvar.h"
#include "./updates.h"
#include "./pidtasks.h"

#define HUG_CLOSED 		3500
#define HUG_OPEN		2877
#define HUG_MIDDLE 		2050
#define HUG_CLIMBPREP	915
#define ARM_UP			950
#define ARM_CLIMB		1495
#define ARM_DOWN		2790
#define ARM_HIGH_FENCE	1200
#define ARM_LOW_FENCE	1405
#define RATCHET_LOCKED	1100
#define RATCHET_DB		600
#define TILE_LENGTH_FOR_DRIVE	660

string autonMode = "ledAuto"; // preloadStraight, leftCube, rightCube, fastForward (rightCube has yet to be tested), ledAuto

task unlockRatchet() {
	while (abs(SensorValue[ratchetAngleSensor] - RATCHET_LOCKED) <= RATCHET_DB) {
		armLockVel = 50;
		updateLockMotors();
	}
	armLockVel = 0;
	updateLockMotors();
}

void pre_auton() {
	bStopTasksBetweenModes = true;
	updateSensors();
	resetTimer();
	resetEncoders();

	startTask(unlockRatchet);

	armTargetAngle = armAngle;
	hugTargetAngle = hugAngle;
}

task preloadStraightAuto() {
	hugTargetAngle = HUG_CLOSED;
	armTargetAngle = ARM_DOWN;
	FLDriveTargetAngle = 0;
	BLDriveTargetAngle = 0;
	FRDriveTargetAngle = 0;
	BRDriveTargetAngle = 0;
	drivePIDMultiplier = 0.3;
	startTask(huggerPID);
	startTask(armPID);
	startTask(drivePostitionPID);
	waitUntil(abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 50);
	armTargetAngle = ARM_UP;
	//FLDriveTargetAngle = 1550;
	//BLDriveTargetAngle = 1550;
	//FRDriveTargetAngle = -1550;
	//BRDriveTargetAngle = -1550;
	waitUntil(abs(SensorValue[armAngleSensor] - armTargetAngle) < 30);
	wait1Msec(500);
	drivePIDMultiplier = 0.5;
	wait1Msec(100);
	drivePIDMultiplier = 0.7;
	wait1Msec(100);
	drivePIDMultiplier = 1;
	//waitUntil(abs(SensorValue[leftEncoderSensor] - FLDriveTargetAngle) < 30);
	hugTargetAngle = HUG_MIDDLE;
	waitUntil(abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 50);
	wait1Msec(500);
	//SensorValue[leftEncoderSensor] = 0;
	//SensorValue[rightEncoderSensor] = 0;
	//FLDriveTargetAngle = -500;
	//rightDriveTargetAngle = 500;
	//waitUntil(abs(SensorValue[leftEncoderSensor] - leftDriveTargetAngle) < 30);
	armTargetAngle += 250;
	waitUntil(abs(SensorValue[armAngleSensor] - armTargetAngle) < 30);
	//SensorValue[leftEncoderSensor] = 0;
	//SensorValue[rightEncoderSensor] = 0;
	//leftDriveTargetAngle = 500;
	//rightDriveTargetAngle = -500;
	stopTask(preloadStraightAuto);
}

task forwardAuto() {
	resetTimer();
	hugTargetAngle = HUG_MIDDLE;
	armTargetAngle = ARM_HIGH_FENCE;
	FLDriveTargetAngle = 1250;
	BLDriveTargetAngle = 1250;
	FRDriveTargetAngle = 1250;
	BRDriveTargetAngle = 1250;
	drivePIDMultiplier = 1.0;
	startTask(huggerPID);
	startTask(armPID);
	startTask(drivePostitionPID);
	waitUntil((abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 30) || getTimer() > 2.5);
	wait1Msec(750);
	armTargetAngle = ARM_UP;
	resetTimer();
	stopTask(forwardAuto);
}

task leftCubeAuto() {
	resetTimer();
	hugTargetAngle = hugAngle;
	armTargetAngle = ARM_DOWN;
	drivePIDMultiplier = 1.0;
	startTask(huggerPID);
	startTask(armPID);
	startTask(drivePostitionPID);

	FLDriveTargetAngle = 600;
	BLDriveTargetAngle = 600;
	FRDriveTargetAngle = 50;
	BRDriveTargetAngle = 50;
	waitUntil((abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 30) || getTimer() > 2.0);
	wait1Msec(250);

	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;
	FLDriveTargetAngle = 0;
	BLDriveTargetAngle = 150;
	FRDriveTargetAngle = 0;
	BRDriveTargetAngle = -150;
	waitUntil((abs(SensorValue[BREncoderSensor] - BRDriveTargetAngle) < 50) || getTimer() > 0.75);
	wait1Msec(250);

	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;
	FLDriveTargetAngle = 400;
	BLDriveTargetAngle = 400;
	FRDriveTargetAngle = 400;
	BRDriveTargetAngle = 400;
	hugTargetAngle += 300;
	armTargetAngle -= 200;
	wait1Msec(250);

	armTargetAngle += 200;
	waitUntil(abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 400);

	hugTargetAngle = 3275;
	waitUntil(abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 30 || getTimer() > 3);

	resetTimer();
	waitUntil((abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 100) || getTimer() > 0.75);
	wait1Msec(500);

	armTargetAngle = ARM_HIGH_FENCE;
	waitUntil((abs(SensorValue[armAngleSensor] - armTargetAngle) < 30));
	wait1Msec(2000);

	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;
	FLDriveTargetAngle = 200;
	BLDriveTargetAngle = -400;
	FRDriveTargetAngle = -200;
	BRDriveTargetAngle = 400;
	waitUntil((abs(SensorValue[BLEncoderSensor] - BLDriveTargetAngle) < 50) || getTimer() > 1.0);
	wait1Msec(2000);

	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;
	FLDriveTargetAngle = 700;
	BLDriveTargetAngle = 700;
	FRDriveTargetAngle = 700;
	BRDriveTargetAngle = 700;
	waitUntil((abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 30) || getTimer() > 1.5);

	hugTargetAngle = HUG_MIDDLE;
	resetTimer();
	waitUntil((abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 30) || getTimer() > 1.0);
	wait1Msec(250);

	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;
	FLDriveTargetAngle = -525;
	BLDriveTargetAngle = -525;
	FRDriveTargetAngle = 0;
	BRDriveTargetAngle = 0;
	waitUntil((abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 30) || getTimer() > 2.0);

	armTargetAngle = ARM_LOW_FENCE;
	wait1Msec(250);
	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;
	FLDriveTargetAngle = 350;
	BLDriveTargetAngle = 350;
	FRDriveTargetAngle = 350;
	BRDriveTargetAngle = 350;
	waitUntil((abs(SensorValue[FLEncoderSensor] - FLDriveTargetAngle) < 30) || getTimer() > 2.0);

	stopTask(leftCubeAuto);
}

task autonomous() {
	pre_auton();

	if (SensorValue[auto1] && !SensorValue[auto2] && SensorValue[auto3]) {
		startTask(forwardAuto);
	} else if (!SensorValue[auto1] && SensorValue[auto2] && SensorValue[auto3]) {
		startTask(leftCubeAuto);
	} else if (SensorValue[auto1] && SensorValue[auto2] && !SensorValue[auto3]) {
		//startTask(rightCubeAuto);
	} else {
		startTask(preloadStraightAuto);
	}
}


task usercontrol() {
	pre_auton();
	while (true) {
		updateJoysticks();
		updateSensors();


		/*
		* Arm Code :/
		*/
		if (LLeft || LLeft_s) {
			armVel = -127;
			climbing = true;
		} else {
			climbing = false;
		}

		if (LBUp)	armTargetAngle = ARM_UP;
		if (LBDown)	armTargetAngle = ARM_DOWN;

		if (LUp) {
			armTargetAngle = ARM_CLIMB;
			hugTargetAngle = HUG_CLIMBPREP;
		}

		if (LDown) {
			armTargetAngle = ARM_LOW_FENCE;
			hugTargetAngle = HUG_MIDDLE;
		}

		if (LRight) {
			armTargetAngle = ARM_HIGH_FENCE;
			hugTargetAngle = HUG_MIDDLE;
		}

		if ((!climbing && wasClimbing) || (!armFineTune && wasArmTuning)) {
			armTargetAngle = armAngle;
		}

		if (!climbing && !armFineTune && !(hugTargetAngle < 850 && armTargetAngle < 1100)) {
			armError = armAngle - armTargetAngle;
			armIntegral += armError;
			armDeriv = armPrevError - armError;
			armVel = (kArmP * armError) + (kArmI * armIntegral) + (kArmD * armDeriv);
			armPrevError = armError;
			if (armVel < -31) armVel = 31 * (armVel/127) * (-armVel/127);
		} else if (hugTargetAngle <= 850) {
			armVel = 0;
		}

		if (armTargetAngle == ARM_UP && armError < 50 && hugTargetAngle > 850) armVel = 20;
		if (abs(armVel) < 20) armVel = 0;

		wasClimbing = climbing;
		wasArmTuning = armFineTune;


		/*
		* Hug code :)
		*/
		if (RRight)		hugTargetAngle = HUG_MIDDLE;
		if (RBDown)		hugTargetAngle = 2877;

		if (!climbing) {
			hugError = hugAngle - hugTargetAngle;
			hugIntegral += hugError;
			hugDeriv = hugPrevError - hugError;
			hugVel = (kHugP * hugError) + (kHugI * hugIntegral) + (kHugD * hugDeriv);
			hugPrevError = hugError;

			if (abs(hugVel) < 20) hugVel = 0;
		}

		if (RBUp){
			hugVel = -127;
			armLocked = true;
		} else if (!LRight && armLocked) {
			hugTargetAngle = hugAngle;
			armLocked = false;
		}

		if (getTimer() >= 1) {
			if (RUp || RUp_s){
				armLockVel = 50;
				armLocked = true;
			} else if (RDown || RDown_s) {
				armLockVel = -50;
			} else if (!LRight && armLocked) {
				hugTargetAngle = hugAngle;
			} else {
				armLockVel = 0;
				armLocked = false;
			}
		}


		/*
		* Drive code
		*/
		FLDriveVel = -LY + LX + RX;
		BLDriveVel = -LY + (LX / 4) - RX;
		FRDriveVel = -LY - LX - RX;
		BRDriveVel = -LY - (LX / 4) + RX;

		FLDriveVel += -LY_s + LX_s + RX_s;
		BLDriveVel += -LY_s + (LX_s / 4) - RX_s;
		FRDriveVel += -LY_s - LX_s - RX_s;
		BRDriveVel += -LY_s - (LX_s / 4) + RX_s;

		if (LLeft || LLeft_s) {
			FLDriveVel = -127;
			BLDriveVel = -127;
			FRDriveVel = -127;
			BRDriveVel = -127;
			armVel = -127;
		}

		FLDriveVel = (abs(FLDriveVel) > 10) ? FLDriveVel : 0;
		BLDriveVel = (abs(BLDriveVel) > 10) ? BLDriveVel : 0;
		FRDriveVel = (abs(FRDriveVel) > 10) ? FRDriveVel : 0;
		BRDriveVel = (abs(BRDriveVel) > 10) ? BRDriveVel : 0;

		updateMotors();
	}
}
