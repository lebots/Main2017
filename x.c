#pragma config(Sensor, in1,    armAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in2,    hugAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in3,    ratchetAngleSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  FLEncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  BLEncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  FREncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  BREncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, auto3,          sensorDigitalIn)
#pragma config(Sensor, dgtl11, auto1,          sensorDigitalIn)
#pragma config(Sensor, dgtl12, auto2,          sensorDigitalIn)
#pragma config(Motor,  port1,           LHug,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           L1Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           R1Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           R2Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           L2Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           FLDrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           BLDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           FRDrive,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           BRDrive,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          armLock,       tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "./joysticks.h"
#include "./xvar.h"

#define HUG_CLOSED 		3500
#define HUG_OPEN		2877
#define HUG_MIDDLE 		2050
#define HUG_CLIMBPREP	915
#define ARM_UP			950
#define ARM_CLIMB		1400
#define ARM_DOWN		2800
#define ARM_HIGH_FENCE	1200
#define ARM_LOW_FENCE	1405
#define RATCHET_LOCKED	1100
#define RATCHET_DB		600
#define TILE_LENGTH_FOR_DRIVE	660

string autonMode = "ledAuto"; // preloadStraight, leftCube, rightCube, fastForward (rightCube has yet to be tested), ledAuto

void updateMotors() {

	motor[FLDrive] = FLDriveVel;
	motor[BLDrive] = BLDriveVel;
	motor[FRDrive] = FRDriveVel;
	motor[BRDrive] = BRDriveVel;

	motor[LHug] = hugVel;

	motor[L1Arm] = armVel;
	motor[L2Arm] = armVel;
	motor[R1Arm] = armVel;
	motor[R2Arm] = armVel;

	motor[armLock] = armLockVel;
}

void updateSensors() {
	armAngle = SensorValue[armAngleSensor];
	hugAngle = SensorValue[hugAngleSensor];
	ratchetAngle = SensorValue[ratchetAngleSensor];
}

task unlockRatchet() {
	while (abs(SensorValue[ratchetAngleSensor] - RATCHET_LOCKED) <= RATCHET_DB) {
		//motor[armLock] = -50;
	}
	//motor[armLock] = 0;
}

void pre_auton() {
	bStopTasksBetweenModes = true;
	updateSensors();
	resetTimer();
	SensorValue[FLEncoderSensor] = 0;
	SensorValue[BLEncoderSensor] = 0;
	SensorValue[FREncoderSensor] = 0;
	SensorValue[BREncoderSensor] = 0;

	startTask(unlockRatchet);


	armTargetAngle = armAngle;
	hugTargetAngle = hugAngle;
}

task huggerPID() {
	while (true) {
		updateSensors();
		hugError = hugAngle - hugTargetAngle;
		hugIntegral += hugError;
		hugDeriv = hugPrevError - hugError;
		hugVel = (kHugP * hugError) + (0.0 * hugIntegral) + (1.0 * hugDeriv);
		hugPrevError = hugError;

		if (hugVel > 127)	hugVel = 127;
		if (hugVel < -127)	hugVel = -127;
		if (abs(hugVel) < 15) hugVel = 0;
		//motor[LHug] = hugVel;
	}
}

task armPID() {
	while (true) {
		updateSensors();
		armError = -(armTargetAngle - armAngle);
		armIntegral += armError;
		armDeriv = armPrevError - armError;
		armVel = (kArmP * armError) + (kArmI * armIntegral) + (kArmD * armDeriv);
		armPrevError = armError;
		if (armVel < -31) armVel = 31 * (armVel/127) * (-armVel/127);

		if (armTargetAngle == 925 && armError < 50) armVel = 20;
		if (abs(armVel) < 20) armVel = 0;

		motor[L1Arm] = armVel;
		motor[L2Arm] = armVel;
		motor[R1Arm] = armVel;
		motor[R2Arm] = armVel;
	}
}

task drivePostitionPID() {
	while (true) {
		FLDriveError = FLDriveTargetAngle - SensorValue[FLEncoderSensor];
		FLDriveIntegral += FLDriveError;
		FLDriveDeriv = FLDrivePrevError - FLDriveError;
		FLDriveVel = (kFLDriveP * FLDriveError) + (kFLDriveI * FLDriveIntegral) + (kFLDriveD * FLDriveDeriv);
		FLDrivePrevError = FLDriveError;

		BLDriveError = BLDriveTargetAngle - SensorValue[BLEncoderSensor];
		BLDriveIntegral += BLDriveError;
		BLDriveDeriv = BLDrivePrevError - BLDriveError;
		BLDriveVel = (kBLDriveP * BLDriveError) + (kBLDriveI * BLDriveIntegral) + (kBLDriveD * BLDriveDeriv);
		BLDrivePrevError = BLDriveError;

		FRDriveError = SensorValue[FREncoderSensor] - FRDriveTargetAngle;
		FRDriveIntegral += FRDriveError;
		FRDriveDeriv = FRDrivePrevError - FRDriveError;
		FRDriveVel = (kFRDriveP * FRDriveError) + (kFRDriveI * FRDriveIntegral) + (kFRDriveD * FRDriveDeriv);
		FRDrivePrevError = FRDriveError;

		BRDriveError = SensorValue[BREncoderSensor] - BRDriveTargetAngle;
		BRDriveIntegral += BRDriveError;
		BRDriveDeriv = BRDrivePrevError - BRDriveError;
		BRDriveVel = (kBRDriveP * BRDriveError) + (kBRDriveI * BRDriveIntegral) + (kBRDriveD * BRDriveDeriv);
		BRDrivePrevError = BRDriveError;

		FLDriveVel *= drivePIDMultiplier;
		BLDriveVel *= drivePIDMultiplier;
		FRDriveVel *= drivePIDMultiplier;
		BRDriveVel *= drivePIDMultiplier;

		if (FLDriveVel > 127) FLDriveVel = 127;
		else if (FLDriveVel < -127) FLDriveVel = -127;
		if (BLDriveVel > 127) BLDriveVel = 127;
		else if (BLDriveVel < -127) BLDriveVel = -127;
		if (FRDriveVel > 127) FRDriveVel = 127;
		else if (FRDriveVel < -127) FRDriveVel = -127;
		if (BRDriveVel > 127) BRDriveVel = 127;
		else if (BRDriveVel < -127) BRDriveVel = -127;

		motor[FLDrive] = FLDriveVel;
		motor[BLDrive] = BLDriveVel;
		motor[FRDrive] = FRDriveVel;
		motor[BRDrive] = BRDriveVel;
	}
}

task preloadStraightAuto() {
	hugTargetAngle = HUG_CLOSED;
	armTargetAngle = ARM_DOWN;
	FLDriveTargetAngle = 0;
	BLDriveTargetAngle = 0;
	FRDriveTargetAngle = 0;
	BRDriveTargetAngle = 0;
	drivePIDMultiplier = 0.3;
	startTask(huggerPID);
	startTask(armPID);
	startTask(drivePostitionPID);
	waitUntil(abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 50);
	armTargetAngle = ARM_UP;
	//FLDriveTargetAngle = 1550;
	//BLDriveTargetAngle = 1550;
	//FRDriveTargetAngle = -1550;
	//BRDriveTargetAngle = -1550;
	waitUntil(abs(SensorValue[armAngleSensor] - armTargetAngle) < 30);
	wait1Msec(500);
	drivePIDMultiplier = 0.5;
	wait1Msec(100);
	drivePIDMultiplier = 0.7;
	wait1Msec(100);
	drivePIDMultiplier = 1;
	//waitUntil(abs(SensorValue[leftEncoderSensor] - FLDriveTargetAngle) < 30);
	hugTargetAngle = HUG_MIDDLE;
	waitUntil(abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 50);
	wait1Msec(500);
	//SensorValue[leftEncoderSensor] = 0;
	//SensorValue[rightEncoderSensor] = 0;
	//FLDriveTargetAngle = -500;
	//rightDriveTargetAngle = 500;
	//waitUntil(abs(SensorValue[leftEncoderSensor] - leftDriveTargetAngle) < 30);
	armTargetAngle += 250;
	waitUntil(abs(SensorValue[armAngleSensor] - armTargetAngle) < 30);
	//SensorValue[leftEncoderSensor] = 0;
	//SensorValue[rightEncoderSensor] = 0;
	//leftDriveTargetAngle = 500;
	//rightDriveTargetAngle = -500;
}

task forwardAuto() {
	resetTimer();
	hugTargetAngle = HUG_MIDDLE;
	armTargetAngle = ARM_HIGH_FENCE;
	//leftDriveTargetAngle = 1550;
	//rightDriveTargetAngle = -1550;
	drivePIDMultiplier = 1.0;
	startTask(huggerPID);
	startTask(armPID);
	startTask(drivePostitionPID);
	//waitUntil((abs(SensorValue[leftEncoderSensor] - leftDriveTargetAngle) < 30) || getTimer() > 2.5);
	wait1Msec(250);
	armTargetAngle = ARM_UP;
	resetTimer();
	//SensorValue[leftEncoderSensor] = 0;
	//SensorValue[rightEncoderSensor] = 0;
	//leftDriveTargetAngle = 200;
	//rightDriveTargetAngle = -200;
	//waitUntil((abs(SensorValue[leftEncoderSensor] - leftDriveTargetAngle) < 30) || getTimer() > 1);
	//SensorValue[leftEncoderSensor] = 0;
	//SensorValue[rightEncoderSensor] = 0;
	//leftDriveTargetAngle = 0;
	//rightDriveTargetAngle = 0;
}

task autonomous() {
	pre_auton();
	updateSensors();
	/*if (autonMode == "preloadStraight") {
		startTask(preloadStraightAuto);
	} else if (autonMode == "leftCube") {
		startTask(leftCubeAuto);
	} else if (autonMode == "rightCube") {
		startTask(rightCubeAuto);
	} else if (autonMode == "fastForward") {
		startTask(forwardAuto);
	} else if (autonMode == "ledAuto") {
		startTask(ledAuto);
	}*/

	// UNTESTED:
	if (SensorValue[auto1] && !SensorValue[auto2] && SensorValue[auto3]) {
		startTask(forwardAuto);
	} else if (!SensorValue[auto1] && SensorValue[auto2] && SensorValue[auto3]) {
		//startTask(leftCubeAuto);
	} else if (SensorValue[auto1] && SensorValue[auto2] && !SensorValue[auto3]) {
		//startTask(rightCubeAuto);
	} else {
		startTask(preloadStraightAuto);
	}
}


task usercontrol() {
	pre_auton();
	while (true) {
		updateJoysticks();
		updateSensors();


		/*
		* Arm Code :/
		*/
		if (LLeft) {
			armVel = -127;
			climbing = true;
		} else {
			climbing = false;
		}

		if (LBUp)	armTargetAngle = ARM_UP;
		if (LBDown)	armTargetAngle = ARM_DOWN;

		if (LUp) {
			armTargetAngle = ARM_CLIMB;
			hugTargetAngle = HUG_CLIMBPREP;
		}

		if (LDown) {
			armTargetAngle = ARM_LOW_FENCE;
			hugTargetAngle = HUG_MIDDLE;
		}

		if (LRight) {
			armTargetAngle = ARM_HIGH_FENCE;
			hugTargetAngle = HUG_MIDDLE;
		}

		if ((!climbing && wasClimbing) || (!armFineTune && wasArmTuning)) {
			armTargetAngle = armAngle;
		}

		if (!climbing && !armFineTune && !(hugTargetAngle < 850 && armTargetAngle < 1100)) {
			armError = armAngle - armTargetAngle;
			armIntegral += armError;
			armDeriv = armPrevError - armError;
			armVel = (kArmP * armError) + (kArmI * armIntegral) + (kArmD * armDeriv);
			armPrevError = armError;
			if (armVel < -31) armVel = 31 * (armVel/127) * (-armVel/127);
		} else if (hugTargetAngle <= 850) {
			armVel = 0;
		}

		if (armTargetAngle == ARM_UP && armError < 50 && hugTargetAngle > 850) armVel = 20;
		if (abs(armVel) < 20) armVel = 0;

		wasClimbing = climbing;
		wasArmTuning = armFineTune;


		/*
		* Hug code :)
		*/
		if (RRight)		hugTargetAngle = HUG_MIDDLE;
		if (RBDown)		hugTargetAngle = 2877;

		if (!climbing) {
			hugError = hugAngle - hugTargetAngle;
			hugIntegral += hugError;
			hugDeriv = hugPrevError - hugError;
			hugVel = (kHugP * hugError) + (kHugI * hugIntegral) + (kHugD * hugDeriv);
			hugPrevError = hugError;

			if (abs(hugVel) < 20) hugVel = 0;
		}

		if (RBUp){
			hugVel = -127;
			armLocked = true;
		} else if (!LRight && armLocked) {
			hugTargetAngle = hugAngle;
			armLocked = false;
		}

		if (getTimer() >= 1) {
			if (RUp){
				armLockVel = 50;
				armLocked = true;
			} else if (RDown) {
				armLockVel = -50;
			} else if (!LRight && armLocked) {
				hugTargetAngle = hugAngle;
			} else {
				armLockVel = 0;
				armLocked = false;
			}
		}


		/*
		* Drive code
		*/
		FLDriveVel = -LY + LX + RX;
		BLDriveVel = -LY + (LX / 4) - RX;
		FRDriveVel = -LY - LX - RX;
		BRDriveVel = -LY - (LX / 4) + RX;

		updateMotors();
	}
}
