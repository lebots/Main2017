#pragma config(Sensor, in1,    armAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in2,    hugAngleSensor, sensorPotentiometer)
#pragma config(Motor,  port1,           LHug,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           L1Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           L2Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           L3Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           R1Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R2Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           R3Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RHug,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int LY = 0; // Left Y-axis Joystick
int LX = 0; // Left X-axis Joystick
int RY = 0; // Right Y-axis Joystick
int RX = 0; // Right X-axis Joystick
int LUp		= false; // Left D-Pad Up Button
int LDown 	= false; // Left D-Pad Down Button
int LLeft 	= false; // Left D-Pad Left Button
int LRight 	= false; // Left D-Pad Right Button
int LBUp	= false; // Left Top Bumper
int LBDown 	= false; // Left Bottom Bumper
int RUp		= false; // Right D-Pad Up Button
int RDown 	= false; // Right D-Pad Down Button
int RLeft 	= false; // Right D-Pad Left Button
int RRight 	= false; // Right D-Pad Right Button
int RBUp	= false; // Right Top Bumper
int RBDown 	= false; // Right Bottom Bumper

int LY_s = 0; // Left Y-axis Joystick on the secondary controller
int LX_s = 0; // Left X-axis Joystick on the secondary controller
int RY_s = 0; // Right Y-axis Joystick on the secondary controller
int RX_s = 0; // Right X-axis Joystick on the secondary controller
int LUp_s		= false; // Left D-Pad Up Button on the secondary controller
int LDown_s 	= false; // Left D-Pad Down Button on the secondary controller
int LLeft_s 	= false; // Left D-Pad Left Button on the secondary controller
int LRight_s 	= false; // Left D-Pad Right Button on the secondary controller
int LBUp_s		= false; // Left Top Bumper on the secondary controller
int LBDown_s 	= false; // Left Bottom Bumper on the secondary controller
int RUp_s		= false; // Right D-Pad Up Button on the secondary controller
int RDown_s 	= false; // Right D-Pad Down Button on the secondary controller
int RLeft_s 	= false; // Right D-Pad Left Button on the secondary controller
int RRight_s 	= false; // Right D-Pad Right Button on the secondary controller
int RBUp_s		= false; // Right Top Bumper on the secondary controller
int RBDown_s 	= false; // Right Bottom Bumper on the secondary controller

int LDriveVel = 0; // Velocity of left drive
int RDriveVel = 0; // Velocity of right drive
int hugVel = 0; // Velocity of hug
int armVel = 0; // Velocity of arm

int armAngle = 0; // Angle of the arm
int hugAngle = 0; // Angle of the hug

int hugTargetAngle 	= 0; // Target angle of hugger
int hugError 		= 0; // Hug angle error for PID
int hugIntegral 	= 0; // Hug integral for PID
int hugDeriv 		= 0; // Hug deriv for PID
int hugPrevError 	= 0; // Hug prev error for PID

void updateJoysticks() {

	LY = vexRT[Ch3];
	LX = vexRT[Ch4];
	RY = vexRT[Ch2];
	RX = vexRT[Ch1];
	LUp		= vexRT[Btn7U];
	LDown   = vexRT[Btn7D];
	LLeft   = vexRT[Btn7L];
	LRight  = vexRT[Btn7R];
	LBUp	= vexRT[Btn5U];
	LBDown  = vexRT[Btn5D];
	RUp		= vexRT[Btn8U];
	RDown   = vexRT[Btn8D];
	RLeft   = vexRT[Btn8L];
	RRight  = vexRT[Btn8R];
	RBUp	= vexRT[Btn6U];
	RBDown  = vexRT[Btn6D];

	LY_s  		= vexRT[Ch3Xmtr2];
	LX_s 		= vexRT[Ch4Xmtr2];
	RY_s 		= vexRT[Ch2Xmtr2];
	RX_s 		= vexRT[Ch1Xmtr2];
	LUp_s 		= vexRT[Btn7UXmtr2];
	LDown_s 	= vexRT[Btn7DXmtr2];
	LLeft_s 	= vexRT[Btn7LXmtr2];
	LRight_s 	= vexRT[Btn7RXmtr2];
	LBUp_s 		= vexRT[Btn5UXmtr2];
	LBDown_s 	= vexRT[Btn5DXmtr2];
	RUp_s 		= vexRT[Btn8UXmtr2];
	RDown_s 	= vexRT[Btn8DXmtr2];
	RLeft_s 	= vexRT[Btn8LXmtr2];
	RRight_s 	= vexRT[Btn8RXmtr2];
	RBUp_s 		= vexRT[Btn6UXmtr2];
	RBDown_s 	= vexRT[Btn6DXmtr2];
}

void updateMotors() {

	motor[LDrive] = LDriveVel;
	motor[RDrive] = RDriveVel;

	motor[LHug] = hugVel;
	motor[RHug] = hugVel;

	motor[L1Arm] = armVel;
	motor[L2Arm] = armVel;
	motor[R1Arm] = armVel;
	motor[R2Arm] = armVel;
}

void updateSensors() {
	armAngle = SensorValue[armAngleSensor];
	hugAngle = SensorValue[hugAngleSensor];
}

void pre_auton() {
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}


task autonomous() {

}


task usercontrol() {
	while (true) {

		updateJoysticks();
		updateSensors();

		hugError = hugTargetAngle - hugAngle;
		hugIntegral += hugError;
		hugDeriv = hugPrevError - hugError;
		hugVel = (0.02 * hugError) + (0.0 * hugIntegral) + (0.0 * hugDeriv);



		if (LBUp)			armVel = 127;
		else if (LBDown)	armVel = -31;
		else if (LDown)		armVel = -127;
		else				armVel = 0;

		if (RUp)			hugTargetAngle = 2700;
		if (RDown)			hugTargetAngle = 300;
		if (RRight)			hugTargetAngle = 1300;

		if (RBUp)			hugVel = 50;
		else if (RBDown)	hugVel = -50;
		else				hugVel = 0;

		/*hugError = hugAngle - hugTargetAngle;
		hugIntegral += hugError;
		hugDeriv = hugPrevError - hugError;
		hugVel = (0.1 * hugError) + (0.0 * hugIntegral) + (1.0 * hugDeriv);
		hugPrevError = hugError;

		hugVel = hugVel / 2;

		if (abs(hugVel) < 15) hugVel = 0;*/

		LDriveVel = LY;
		RDriveVel = RY;

		if (abs(LY) < 10) LY = 0;
		if (abs(RY) < 10) RY = 0;

		updateMotors();
	}
}
