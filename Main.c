#pragma config(Sensor, in1,    armAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in2,    hugAngleSensor, sensorPotentiometer)
#pragma config(Motor,  port1,           LHug,          tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           L1Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           L2Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           L3Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           R1Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R2Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           R3Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RHug,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

int LY = 0; // Left Y-axis Joystick
int LX = 0; // Left X-axis Joystick
int RY = 0; // Right Y-axis Joystick
int RX = 0; // Right X-axis Joystick
int LUp		= false; // Left D-Pad Up Button
int LDown 	= false; // Left D-Pad Down Button
int LLeft 	= false; // Left D-Pad Left Button
int LRight 	= false; // Left D-Pad Right Button
int LBUp	= false; // Left Top Bumper
int LBDown 	= false; // Left Bottom Bumper
int RUp		= false; // Right D-Pad Up Button
int RDown 	= false; // Right D-Pad Down Button
int RLeft 	= false; // Right D-Pad Left Button
int RRight 	= false; // Right D-Pad Right Button
int RBUp	= false; // Right Top Bumper
int RBDown 	= false; // Right Bottom Bumper

int LY_s = 0; // Left Y-axis Joystick on the secondary controller
int LX_s = 0; // Left X-axis Joystick on the secondary controller
int RY_s = 0; // Right Y-axis Joystick on the secondary controller
int RX_s = 0; // Right X-axis Joystick on the secondary controller
int LUp_s		= false; // Left D-Pad Up Button on the secondary controller
int LDown_s 	= false; // Left D-Pad Down Button on the secondary controller
int LLeft_s 	= false; // Left D-Pad Left Button on the secondary controller
int LRight_s 	= false; // Left D-Pad Right Button on the secondary controller
int LBUp_s		= false; // Left Top Bumper on the secondary controller
int LBDown_s 	= false; // Left Bottom Bumper on the secondary controller
int RUp_s		= false; // Right D-Pad Up Button on the secondary controller
int RDown_s 	= false; // Right D-Pad Down Button on the secondary controller
int RLeft_s 	= false; // Right D-Pad Left Button on the secondary controller
int RRight_s 	= false; // Right D-Pad Right Button on the secondary controller
int RBUp_s		= false; // Right Top Bumper on the secondary controller
int RBDown_s 	= false; // Right Bottom Bumper on the secondary controller

int LDriveVel = 0; // Velocity of left drive
int RDriveVel = 0; // Velocity of right drive
int hugVel = 0; // Velocity of hug
int armVel = 0; // Velocity of arm

int armAngle = 0; // Angle of the arm
int hugAngle = 0; // Angle of the hug

int hugTargetAngle	= 1300; // Target angle of hugger
int hugError 		= 0; // Hug angle error for PID
int hugIntegral 	= 0; // Hug integral for PID
int hugDeriv 		= 0; // Hug deriv for PID
int hugPrevError 	= 0; // Hug prev error for PID

int armTargetAngle	= 2700; // Target angle of arm
int armError 		= 0; // Arm angle error for PID
int armIntegral 	= 0; // Arm integral for PID
int armDeriv 		= 0; // Arm deriv for PID
int armPrevError 	= 0; // Arm prev error for PID

bool climbing = false;
bool wasClimbing = false;

void updateJoysticks() {

	LY = vexRT[Ch3];
	LX = vexRT[Ch4];
	RY = vexRT[Ch2];
	RX = vexRT[Ch1];
	LUp		= vexRT[Btn7U];
	LDown   = vexRT[Btn7D];
	LLeft   = vexRT[Btn7L];
	LRight  = vexRT[Btn7R];
	LBUp	= vexRT[Btn5U];
	LBDown  = vexRT[Btn5D];
	RUp		= vexRT[Btn8U];
	RDown   = vexRT[Btn8D];
	RLeft   = vexRT[Btn8L];
	RRight  = vexRT[Btn8R];
	RBUp	= vexRT[Btn6U];
	RBDown  = vexRT[Btn6D];

	LY_s  		= vexRT[Ch3Xmtr2];
	LX_s 		= vexRT[Ch4Xmtr2];
	RY_s 		= vexRT[Ch2Xmtr2];
	RX_s 		= vexRT[Ch1Xmtr2];
	LUp_s 		= vexRT[Btn7UXmtr2];
	LDown_s 	= vexRT[Btn7DXmtr2];
	LLeft_s 	= vexRT[Btn7LXmtr2];
	LRight_s 	= vexRT[Btn7RXmtr2];
	LBUp_s 		= vexRT[Btn5UXmtr2];
	LBDown_s 	= vexRT[Btn5DXmtr2];
	RUp_s 		= vexRT[Btn8UXmtr2];
	RDown_s 	= vexRT[Btn8DXmtr2];
	RLeft_s 	= vexRT[Btn8LXmtr2];
	RRight_s 	= vexRT[Btn8RXmtr2];
	RBUp_s 		= vexRT[Btn6UXmtr2];
	RBDown_s 	= vexRT[Btn6DXmtr2];
}

void updateMotors() {

	motor[LDrive] = LDriveVel;
	motor[RDrive] = RDriveVel;

	motor[LHug] = hugVel;
	motor[RHug] = hugVel;

	motor[L1Arm] = armVel;
	motor[L2Arm] = armVel;
	motor[R1Arm] = armVel;
	motor[R2Arm] = armVel;
}

void updateSensors() {
	armAngle = SensorValue[armAngleSensor];
	hugAngle = SensorValue[hugAngleSensor];
}

void pre_auton() {
  bStopTasksBetweenModes = true;
  updateSensors();

  armTargetAngle = armAngle;
  hugTargetAngle = hugAngle;
}


task autonomous() {

}


task usercontrol() {
	while (true) {

		updateJoysticks();
		updateSensors();


		/*
		* Arm Code :/
		*/
		climbing = (bool)LDown;
		if (LDown) {
			armVel = -127;
			climbing = true;
		} else {
			climbing = false;
		}

		if (LUp)	armTargetAngle = 925;
		if (LRight)	armTargetAngle = 1250;
		if (LLeft)	armTargetAngle = 2770;

		if (!climbing && wasClimbing) {
			armTargetAngle = armAngle;
		}

		if (!climbing) {
			armError = -(armTargetAngle - armAngle);
			armIntegral += armError;
			armDeriv = armPrevError - armError;
			armVel = (0.9 * armError) + (0.0 * armIntegral) + (0.0 * armDeriv);
			armPrevError = armError;
			if (armVel < -31) armVel = 31 * (armVel/127) * (-armVel/127);
		}

		if (armTargetAngle == 925 && armError < 50) armVel = 0;
		if (abs(armVel) < 25) armVel = 0;

		/*if (LBUp)			armVel = 127;
		else if (LBDown)	armVel = -31;
		else if (LDown)		armVel = -127;
		else				armVel = 0;*/


		/*
		* Hug code :)
		*/
		if (RUp)			hugTargetAngle = 2700;
		if (RDown)			hugTargetAngle = 300;
		if (RRight)			hugTargetAngle = 1300;

		/*if (RBUp)			hugVel = 50;
		else if (RBDown)	hugVel = -50;
		else				hugVel = 0;*/

		hugError = hugAngle - hugTargetAngle;
		hugIntegral += hugError;
		hugDeriv = hugPrevError - hugError;
		hugVel = (0.1 * hugError) + (0.0 * hugIntegral) + (1.0 * hugDeriv);
		hugPrevError = hugError;

		if (hugVel > 50)	hugVel = 50;
		if (hugVel < -50)	hugVel = -50;
		if (abs(hugVel) < 15) hugVel = 0;


		/*
		* Drive code
		*/
		LDriveVel = LY;
		RDriveVel = RY;

		if (abs(LY) < 15) LY = 0;
		if (abs(RY) < 15) RY = 0;

		updateMotors();
		wasClimbing = climbing;
	}
}
