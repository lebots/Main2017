#pragma config(Sensor, in1,    armAngleSensor, sensorPotentiometer)
#pragma config(Sensor, in2,    hugAngleSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoderSensor, sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoderSensor, sensorQuadEncoder)
#pragma config(Motor,  port1,           LHug,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           L1Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           L2Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           L3Arm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           R1Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           R2Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           R3Arm,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          armLock,       tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#include "C:/Users/Cameron/Documents/LebotsCode/Main2017/joysticks.h"

#define HUG_CLOSED 		3550
#define HUG_OPEN		900
#define HUG_MIDDLE 		2050
#define HUG_CLIMBPREP	915
#define ARM_UP			950
#define ARM_CLIMB		1415
#define ARM_DOWN		2800

int LDriveVel = 0; // Velocity of left drive
int RDriveVel = 0; // Velocity of right drive
int hugVel = 0; // Velocity of hug
int armVel = 0; // Velocity of arm

int armAngle = 0; // Angle of the arm
int hugAngle = 0; // Angle of the hug

int hugTargetAngle	= 1300; // Target angle of hugger
int hugError 		= 0; // Hug angle error for PID
int hugIntegral 	= 0; // Hug integral for PID
int hugDeriv 		= 0; // Hug deriv for PID
int hugPrevError 	= 0; // Hug prev error for PID
float kHugP = 0.1;
float kHugI = 0.0;
float kHugD = 1.0;

int armTargetAngle	= 2700; // Target angle of arm
int armError 		= 0; // Arm angle error for PID
int armIntegral 	= 0; // Arm integral for PID
int armDeriv 		= 0; // Arm deriv for PID
int armPrevError 	= 0; // Arm prev error for PID
float kArmP = 0.9;
float kArmI = 0.0;
float kArmD = 0.0;

int leftDriveTargetAngle	= 0; // Encoder pos for left drive PID
int leftDriveError 		= 0; // Left Drive positional error for PID
int leftDriveIntegral 	= 0; // Left Drive integral for PID
int leftDriveDeriv 		= 0; // Left Drive deriv for PID
int leftDrivePrevError 	= 0; // Left Drive prev error for PID
float kLeftDriveP = 0.9;
float kLeftDriveI = 0.0;
float kLeftDriveD = 0.0;

int rightDriveTargetAngle	= 0; // Encoder pos for right drive PID
int rightDriveError 		= 0; // Right Drive positional error for PID
int rightDriveIntegral 		= 0; // Right Drive integral for PID
int rightDriveDeriv 		= 0; // Right Drive deriv for PID
int rightDrivePrevError 	= 0; // Right Drive prev error for PID
float kRightDriveP = 0.9;
float kRightDriveI = 0.0;
float kRightDriveD = 0.0;

int armLockVel = 0; // Velocity of locking motor for ratchet after climb

bool climbing = false;
bool wasClimbing = false;
bool armLocked = false;

string autonMode = "preload";

void updateMotors() {

	motor[LDrive] = LDriveVel;
	motor[RDrive] = RDriveVel;

	motor[LHug] = hugVel;
	//motor[RHug] = hugVel;

	motor[L1Arm] = armVel;
	motor[L2Arm] = armVel;
	motor[L3Arm] = armVel;
	motor[R1Arm] = armVel;
	motor[R2Arm] = armVel;
	motor[R3Arm] = armVel;

	motor[armLock] = armLockVel;
}

void updateSensors() {
	armAngle = SensorValue[armAngleSensor];
	hugAngle = SensorValue[hugAngleSensor];
}

void pre_auton() {
  bStopTasksBetweenModes = true;
  updateSensors();


  armTargetAngle = armAngle;
  hugTargetAngle = hugAngle;
}

task huggerPID() {
	while (true) {
		updateSensors();
		hugError = hugAngle - hugTargetAngle;
		hugIntegral += hugError;
		hugDeriv = hugPrevError - hugError;
		hugVel = (0.1 * hugError) + (0.0 * hugIntegral) + (1.0 * hugDeriv);
		hugPrevError = hugError;

		if (hugVel > 100)	hugVel = 100;
		if (hugVel < -100)	hugVel = -100;
		if (abs(hugVel) < 15) hugVel = 0;
		//motor[RHug] = hugVel;
		motor[LHug] = hugVel;
	}
}

task armPID() {
	while (true) {
		updateSensors();
		armError = -(armTargetAngle - armAngle);
		armIntegral += armError;
		armDeriv = armPrevError - armError;
		armVel = (kArmP * armError) + (kArmI * armIntegral) + (kArmD * armDeriv);
		armPrevError = armError;
		if (armVel < -31) armVel = 31 * (armVel/127) * (-armVel/127);

		if (armTargetAngle == 925 && armError < 50) armVel = 20;
		if (abs(armVel) < 20) armVel = 0;

		motor[L1Arm] = armVel;
		motor[L2Arm] = armVel;
		motor[L3Arm] = armVel;
		motor[R1Arm] = armVel;
		motor[R2Arm] = armVel;
		motor[R3Arm] = armVel;
	}
}

task drivePostitionPID() {
	while (true) {
		leftDriveError = SensorValue[leftEncoderSensor]- leftDriveTargetAngle;
		leftDriveIntegral += leftDriveError;
		leftDriveDeriv = leftDrivePrevError - leftDriveError;
		LDriveVel = (0.1 * leftDriveError) + (0.0 * leftDriveIntegral) + (1.0 * leftDriveDeriv);
		leftDrivePrevError = leftDriveError;

		leftDriveError = SensorValue[leftEncoderSensor]- leftDriveTargetAngle;
		leftDriveIntegral += leftDriveError;
		leftDriveDeriv = leftDrivePrevError - leftDriveError;
		LDriveVel = (0.1 * leftDriveError) + (0.0 * leftDriveIntegral) + (1.0 * leftDriveDeriv);
		leftDrivePrevError = leftDriveError;
	}
}

task preloadAuto() {
	hugTargetAngle = HUG_CLOSED;
	armTargetAngle = ARM_DOWN;
	startTask(huggerPID);
	startTask(armPID);
	waitUntil(abs(SensorValue[hugAngleSensor] - hugTargetAngle) < 50);
	armTargetAngle = ARM_UP;
	waitUntil(abs(SensorValue[armAngleSensor] - armTargetAngle) < 30);
	motor[LDrive] = 63;
	motor[RDrive] = 63;
	wait1Msec(500);
	motor[LDrive] = 127;
	motor[RDrive] = 127;
	wait1Msec(2500);
	motor[LDrive] = 0;
	motor[RDrive] = 0;
	wait1Msec(500);
	hugTargetAngle = HUG_MIDDLE;
}

task autonomous() {
	updateSensors();
	if (autonMode == "preload") {
		startTask(preloadAuto);
	}
}


task usercontrol() {
	while (true) {

		updateJoysticks();
		updateSensors();


		/*
		* Arm Code :/
		*/
		//climbing = (bool)LDown;
		if (LLeft) {
			armVel = -127;
			climbing = true;
		} else {
			climbing = false;
		}

		if (LBUp)	armTargetAngle = ARM_UP;
		if (LUp)	armTargetAngle = ARM_CLIMB;
		if (LBDown)	armTargetAngle = ARM_DOWN;

		if (!climbing && wasClimbing) {
			armTargetAngle = armAngle;
		}

		if (!climbing && !(hugTargetAngle < 850 && armTargetAngle < 1100)) {
			armError = armAngle - armTargetAngle;
			armIntegral += armError;
			armDeriv = armPrevError - armError;
			armVel = (kArmP * armError) + (kArmI * armIntegral) + (kArmD * armDeriv);
			armPrevError = armError;
			if (armVel < -31) armVel = 31 * (armVel/127) * (-armVel/127);
		} else if (hugTargetAngle <= 850) {
			armVel = 0;
		}

		if (armTargetAngle == ARM_UP && armError < 50 && hugTargetAngle > 850) armVel = 20;
		if (abs(armVel) < 20) armVel = 0;

		wasClimbing = climbing;


		/*
		* Hug code :)
		*/
		//if (RBUp)		hugTargetAngle = HUG_CLOSED;
		if (RDown)		hugTargetAngle = HUG_OPEN;
		if (RRight)		hugTargetAngle = HUG_MIDDLE;
		if (RBDown)		hugTargetAngle = 2877;
		if (LUp)		hugTargetAngle = HUG_CLIMBPREP;

		if (!climbing) {
			hugError = hugAngle - hugTargetAngle;
			hugIntegral += hugError;
			hugDeriv = hugPrevError - hugError;
			hugVel = (0.5 * hugError) + (kHugI * hugIntegral) + (kHugD * hugDeriv);
			hugPrevError = hugError;

			/*if (hugVel > 50)	hugVel = 127;
			if (hugVel < -50)	hugVel = -127;*/
			if (abs(hugVel) < 20) hugVel = 0;
			if (hugTargetAngle == HUG_MIDDLE && hugAngle < HUG_MIDDLE) hugVel = -20;
		}

		if (RBUp){
			hugVel = -50;
			armLocked = true;
		} else if (!RLeft && armLocked) {
			hugTargetAngle = hugAngle;
			armLocked = false;
		}

		if (RUp){
			//hugVel = 100;
			armLockVel = 50;
			armLocked = true;
		} else {
			//hugTargetAngle = hugAngle;
			armLockVel = 0;
			armLocked = false;
		}


		/*
		* Drive code
		*/
		LDriveVel = LY;
		RDriveVel = RY;

		if (LLeft) {
			LDriveVel = 127;
			RDriveVel = 127;
		}

		if (abs(LDriveVel) < 15) LDriveVel = 0;
		if (abs(RDriveVel) < 15) RDriveVel = 0;

		updateMotors();
	}
}
